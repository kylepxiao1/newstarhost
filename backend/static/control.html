<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Battle Control</title>
  <style>
    body { font-family: "Segoe UI", Arial, sans-serif; margin: 0; background: #0f172a; color: #e2e8f0; }
    header { padding: 16px 24px; background: #1e293b; box-shadow: 0 2px 6px rgba(0,0,0,.3); display: flex; align-items: center; justify-content: space-between; }
    h1 { margin: 0; font-size: 20px; }
    main { padding: 20px 24px; display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    section { background: #111827; border: 1px solid #1f2937; border-radius: 10px; padding: 16px; box-shadow: inset 0 1px 0 rgba(255,255,255,.02); }
    h2 { margin-top: 0; font-size: 16px; letter-spacing: 0.02em; }
    .row { display: flex; gap: 8px; margin-bottom: 10px; }
    button { cursor: pointer; background: #2563eb; color: #fff; border: none; border-radius: 6px; padding: 8px 12px; font-weight: 600; }
    button.secondary { background: #334155; }
    button.danger { background: #ef4444; }
    input, select { padding: 8px; border-radius: 6px; border: 1px solid #334155; background: #0b1222; color: #e2e8f0; }
    ul { list-style: none; padding: 0; margin: 0; max-height: 220px; overflow: auto; }
    li { padding: 8px; border-bottom: 1px solid #1f2937; display: flex; justify-content: space-between; align-items: center; }
    .badge { padding: 4px 8px; border-radius: 6px; background: #1e293b; font-size: 12px; }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .status { display: inline-flex; align-items: center; gap: 6px; font-weight: 700; text-transform: uppercase; }
    .dot { width: 10px; height: 10px; border-radius: 50%; background: #22c55e; }
    table { width: 100%; border-collapse: collapse; }
    td { padding: 6px 4px; border-bottom: 1px solid #1f2937; }
    .overlay-toggle { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; padding: 6px 8px; background: #0b1222; border-radius: 6px; }
    .bar-wrap { width: 100%; height: 18px; background: #0b1222; border: 1px solid #1f2937; border-radius: 10px; overflow: hidden; display: flex; }
    .bar-left { background: #ef4444; height: 100%; }
    .bar-right { background: #3b82f6; height: 100%; }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>TikTok Battle Control</h1>
      <div class="status"><span class="dot" id="wsDot"></span><span id="statusText">Connecting</span></div>
    </div>
    <div id="current"></div>
  </header>
  <main>
    <section>
      <h2>Battle</h2>
      <div class="row">
        <button class="secondary" onclick="startRoutine()">Simulate 2m Battle Routine</button>
        <button class="danger" onclick="cancelRoutine()">Cancel Routine</button>
      </div>
      <div class="row">
        <span>Timer: <strong id="timerDisplay">-</strong></span>
      </div>
      <div class="row">
        <label style="display:flex;gap:6px;align-items:center; width:100%;">
          <span style="white-space:nowrap;">Last winner:</span>
          <select id="winnerSelect" style="flex:1;" onchange="saveWinnerSelect()"></select>
        </label>
      </div>
      <div class="row">
        <label style="display:flex;gap:6px;align-items:center; width:100%;">
          <span style="white-space:nowrap;">Current group:</span>
          <select id="groupSelect" style="flex:1;" onchange="saveGroupSelect()"></select>
        </label>
      </div>
      <div class="row" id="enabledDancers"></div>
      <div class="row" id="winsEditor" style="flex-wrap:wrap; gap:8px;"></div>
      <table>
        <tr><td>Mode</td><td id="modeCell">-</td></tr>
        <tr><td>Slot One</td><td id="slotOneCell">-</td></tr>
        <tr><td>Slot Two</td><td id="slotTwoCell">-</td></tr>
        <tr><td>Points</td><td>
          <div class="bar-wrap"><div id="barLeft" class="bar-left" style="width:50%"></div><div id="barRight" class="bar-right" style="width:50%"></div></div>
          <div class="row" style="margin-top:4px; gap:12px;">
            <span id="pointsLeftLabel">0</span>
            <span id="pointsRightLabel" style="margin-left:auto;">0</span>
          </div>
        </td></tr>
      </table>
      <div class="row">
        <button class="secondary" onclick="pullFromStudio()">Sync from TikTok Studio</button>
      </div>
    </section>

    <section>
      <h2>Overlays</h2>
      <div id="overlays"></div>
    </section>

    <section>
      <h2>Music Control</h2>
      <div class="row">
        <button class="secondary" id="tabGroup" onclick="selectTab('group')">Group</button>
        <button class="secondary" id="tabOne" onclick="selectTab('slot_one')">Dancer 1</button>
        <button class="secondary" id="tabTwo" onclick="selectTab('slot_two')">Dancer 2</button>
      </div>
      <div class="row">
        <input id="songFilter" placeholder="Search songs" style="flex:1;" list="songSuggestions" oninput="renderSongs()" onchange="filterSelected()">
        <datalist id="songSuggestions"></datalist>
      </div>
      <div class="row">
        <select id="songSelect" style="flex:1;"></select>
        <button onclick="playSong()">Play Song</button>
      </div>
      <div class="row" style="align-items:center;">
        <label style="display:flex;gap:6px;align-items:center;">
          <input type="checkbox" id="fadeToggle" checked> Fade in 0.5s
        </label>
        <label style="display:flex;gap:6px;align-items:center;">
          <input type="checkbox" id="fadeOutToggle" checked> Fade out 0.5s
        </label>
      </div>
      <div class="row">
        <span>Current song: <span id="currentSongLabel">-</span></span>
      </div>
      <audio id="player" preload="auto" controls style="width:100%;" loop></audio>
      <audio id="applause" preload="auto" src="https://actions.google.com/sounds/v1/crowds/applause_small_group.ogg"></audio>
    </section>

    <section>
      <h2>Virtual Cam Preview</h2>
      <div class="row">
        <select id="cameraSelect" style="flex:1;"></select>
        <button class="secondary" onclick="refreshCameras()">Refresh Cameras</button>
      </div>
      <div class="row">
        <button class="secondary" onclick="startPreview()">Start Preview</button>
      </div>
      <video id="preview" width="100%" autoplay playsinline style="background:#0b1222;border:1px solid #1f2937;border-radius:8px;"></video>
    </section>
  </main>

  <script>
    const api = (path, opts={}) => fetch(path, {method: opts.method||"GET", headers: {"Content-Type":"application/json"}, body: opts.body ? JSON.stringify(opts.body) : undefined});
    let state = {};
    let currentTab = "group";
    let routine = { active:false, timers:[], endTime:0, startTime:0, dancers:[], firstSongPlayed:false, warned:false, pointsInterval:null, switchInterval:null, currentSongOwner:"", currentSongUrl:"" };
    let timerInterval = null;
    const SPECIAL_ROLES = ["bell","applause","attention","background","win"];
    const CENTER_LINE = "CenterDottedLine";

    function renderState() {
      document.getElementById("modeCell").textContent = state.battle_mode || "-";
      document.getElementById("slotOneCell").textContent = state.slot_one || "-";
      document.getElementById("slotTwoCell").textContent = state.slot_two || "-";
      renderPointsBar();
      renderWinnerSelect();
      renderGroupSelect();
      renderEnabledDancers();
      renderWinsEditor();
      renderOverlays();
      renderSongs();
      renderTimer();
    }

    function renderPointsBar() {
      const scores = state.scores || {slot_one:0, slot_two:0};
      const a = scores.slot_one || 0;
      const b = scores.slot_two || 0;
      const total = Math.max(1, a + b);
      const leftPct = Math.round((a / total) * 100);
      const rightPct = 100 - leftPct;
      const leftEl = document.getElementById("barLeft");
      const rightEl = document.getElementById("barRight");
      const leftLabel = document.getElementById("pointsLeftLabel");
      const rightLabel = document.getElementById("pointsRightLabel");
      if (leftEl) leftEl.style.width = `${leftPct}%`;
      if (rightEl) rightEl.style.width = `${rightPct}%`;
      if (leftLabel) leftLabel.textContent = a;
      if (rightLabel) rightLabel.textContent = b;
    }

    function renderOverlays() {
      const wrap = document.getElementById("overlays");
      wrap.innerHTML = "";
      const overlays = state.overlay_states || {};
      if (!routine.active && overlays[CENTER_LINE]) {
        setCenterLine(false);
        overlays[CENTER_LINE] = false;
      }
      Object.keys(overlays).forEach(name => {
        const row = document.createElement("div");
        row.className = "overlay-toggle";
        row.innerHTML = `<span>${name}</span>`;
        const btn = document.createElement("button");
        btn.textContent = overlays[name] ? "Hide" : "Show";
        btn.onclick = () => toggleOverlay(name, !overlays[name]);
        row.appendChild(btn);
        wrap.appendChild(row);
      });
    }

    function renderWinnerSelect() {
      const sel = document.getElementById("winnerSelect");
      if (!sel) return;
      sel.innerHTML = "";
      const current = (state.last_winner || "").toLowerCase();
      const opts = [];
      const enabled = state.enabled_dancers || [];
      const enabledSet = new Set(enabled.map(x=>x.toLowerCase()));
      (state.dancers || []).forEach(d => {
        const name = d.name || "";
        if (!name) return;
        if (enabled.length && !enabledSet.has(name.toLowerCase())) return;
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        if (name.toLowerCase() === current) opt.selected = true;
        opts.push(opt);
      });
      // add empty option
      const empty = document.createElement("option");
      empty.value = "";
      empty.textContent = "(none)";
      sel.appendChild(empty);
      opts.forEach(o => sel.appendChild(o));
      if (current && !sel.value) sel.value = current;
    }

    function renderGroupSelect() {
      const sel = document.getElementById("groupSelect");
      if (!sel) return;
      sel.innerHTML = "";
      const current = (state.group_name || "").toLowerCase();
      const opts = [];
      const enabled = state.enabled_dancers || [];
      const enabledSet = new Set(enabled.map(x=>x.toLowerCase()));
      (state.dancers || []).forEach(d => {
        const name = d.name || "";
        if (!name) return;
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        if (name.toLowerCase() === current) opt.selected = true;
        opts.push(opt);
      });
      const empty = document.createElement("option");
      empty.value = "";
      empty.textContent = "(none)";
      sel.appendChild(empty);
      opts.forEach(o => sel.appendChild(o));
      if (current && !sel.value) sel.value = current;
    }

    function renderEnabledDancers() {
      const container = document.getElementById("enabledDancers");
      if (!container) return;
      container.innerHTML = "";
      const enabled = new Set((state.enabled_dancers || []).map(x => (x||"").toLowerCase()));
      (state.dancers || []).forEach(d => {
        const name = d.name || "";
        if (!name) return;
        const wrap = document.createElement("label");
        wrap.style.display = "flex";
        wrap.style.alignItems = "center";
        wrap.style.gap = "6px";
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = enabled.has(name.toLowerCase());
        cb.onchange = () => toggleEnabledDancer(name, cb.checked);
        const span = document.createElement("span");
        span.textContent = name;
        wrap.appendChild(cb);
        wrap.appendChild(span);
        container.appendChild(wrap);
      });
    }

    function renderWinsEditor() {
      const container = document.getElementById("winsEditor");
      if (!container) return;
      container.innerHTML = "";
      const wins = state.win_counts || {};
      const enabled = new Set((state.enabled_dancers || []).map(x => (x||"").toLowerCase()));
      (state.dancers || []).forEach(d => {
        const name = d.name || "";
        if (!name) return;
        if (enabled.size && !enabled.has(name.toLowerCase())) return;
        const wrap = document.createElement("div");
        wrap.style.display = "flex";
        wrap.style.alignItems = "center";
        wrap.style.gap = "4px";
        const label = document.createElement("span");
        label.textContent = name;
        const input = document.createElement("input");
        input.type = "number";
        input.min = "0";
        input.value = wins[name] || 0;
        input.style.width = "70px";
        const btn = document.createElement("button");
        btn.textContent = "Save";
        btn.onclick = () => {
          const val = parseInt(input.value, 10);
          api("/battle/win", {method:"POST", body:{name, wins: isNaN(val)?0:val}}).then(refreshState);
        };
        wrap.appendChild(label);
        wrap.appendChild(input);
        wrap.appendChild(btn);
        container.appendChild(wrap);
      });
    }

    function refreshState() {
      api("/state").then(r => r.json()).then(s => { state = s; renderState(); renderGroupSelect(); renderWinnerSelect(); });
    }

    function startBattle() {
      routine.active = false;
      clearRoutineTimers();
      setCenterLine(false);
      api("/battle/start", {method:"POST", body:{}}).then(refreshState);
    }
    function endBattle() {
      routine.active = false;
      clearRoutineTimers();
      api("/battle/end", {method:"POST"}).then(refreshState);
    }
    function addScore(slot) { api(`/score/${slot}/add`, {method:"POST", body:{amount:1}}).then(refreshState); }
    function pullFromStudio() {
      // External automation should POST to /battle/slots/import; this button just refreshes state.
      refreshState();
    }
    function toggleOverlay(name, show) { api(`/overlay/${name}/${show?"show":"hide"}`, {method:"POST"}).then(refreshState); }

    function selectTab(tab) {
      currentTab = tab;
      ["tabGroup","tabOne","tabTwo"].forEach(id=>{
        const el = document.getElementById(id);
        if (!el) return;
        const isActive = (id==="tabGroup" && tab==="group") || (id==="tabOne" && tab==="slot_one") || (id==="tabTwo" && tab==="slot_two");
        el.className = isActive ? "secondary active" : "secondary";
      });
      renderSongs();
    }

    function renderSongs() {
      const songs = state.songs || {};
      const lib = songs.library || {};
      const currentUrl = songs.current || "";
      const backgroundUrl = songs.background || "";
      const filter = (document.getElementById("songFilter").value || "").toLowerCase();
      const tabFilter = currentTab === "slot_one" ? (state.slot_one || "").toLowerCase()
                     : currentTab === "slot_two" ? (state.slot_two || "").toLowerCase()
                     : currentTab === "group" ? (state.group_name || "").toLowerCase()
                     : "";
      const datalist = document.getElementById("songSuggestions");
      datalist.innerHTML = "";
      let currentName = "-";
      const tryResolve = (url) => {
        let name = "-";
        Object.values(lib).forEach(item => {
          if (item.url === url) {
            name = item.name || url;
          }
        });
        if (name === "-" && url && url === backgroundUrl) {
          name = "Background";
        }
        if (name === "-" && url) name = url;
        return name;
      };
      if (currentUrl) {
        currentName = tryResolve(currentUrl);
      } else if (backgroundUrl) {
        currentName = tryResolve(backgroundUrl);
      }
      document.getElementById("currentSongLabel").textContent = currentName;
      const select = document.getElementById("songSelect");
      select.innerHTML = "";
      Object.keys(lib).forEach(key => {
        const opt = document.createElement("option");
        opt.value = lib[key].url;
        let label = lib[key].name || key;
        const fronts = (lib[key].front_dancers || []).join(", ");
        if (fronts) {
          label += ` (Front: ${fronts})`;
        }
        opt.textContent = label;
        const dancerMatch = tabFilter
          ? (lib[key].dancers || []).some(d => (d || "").toLowerCase().includes(tabFilter))
          : true;
        const matches = (!filter || label.toLowerCase().includes(filter)) && dancerMatch;
        if (matches) {
          select.appendChild(opt);
        }
        if (matches) {
          const dOpt = document.createElement("option");
          dOpt.value = label;
          datalist.appendChild(dOpt);
        }
      });
      if (!select.value && select.options.length) select.selectedIndex = 0;
      select.onchange = () => playSong(true);
    }

    function filterSelected() {
      const filterVal = document.getElementById("songFilter").value.toLowerCase();
      const select = document.getElementById("songSelect");
      for (let i = 0; i < select.options.length; i++) {
        if (select.options[i].textContent.toLowerCase() === filterVal) {
          select.selectedIndex = i;
          playSong(true);
          break;
        }
      }
    }

    function refreshSongs() {
      api("/songs").then(r => r.json()).then(s => {
        if (!state.songs) state.songs = {};
        state.songs.library = s.library || {};
        state.songs.background = s.background || state.songs.background;
        state.songs.current = state.songs.current || s.current || "";
        renderSongs();
        ensureBackground();
      });
    }

    async function playSong(fromSelect=false) {
      const select = document.getElementById("songSelect");
      const url = select.value;
      if (!url) {
        if (fromSelect) return;
        return alert("Enter a song URL");
      }
      // cancel routine if user manually picks music
      cancelRoutine();
      await api("/songs/play", {method:"POST", body:{target: currentTab, url}});
      const songs = state.songs || {};
      songs.current = url;
      songs[currentTab] = url;
      state.songs = songs;
      // play selected -> applause -> background
      startAudio(url, {loop:false, onEnd: () => {
        playSequence(["applause"], false, () => {
          const bg = state.songs?.background;
          if (bg) startAudio(bg, {loop:true});
        });
      }});
      refreshState();
    }

    function startAudio(url, opts={}) {
      const player = document.getElementById("player");
      const fadeIn = opts.fade ?? document.getElementById("fadeToggle")?.checked ?? true;
      const fadeOut = opts.fadeOut ?? document.getElementById("fadeOutToggle")?.checked ?? true;
      const doPlay = () => {
        player.loop = !!opts.loop;
        player.onended = () => {
          if (typeof opts.onEnd === "function") {
            opts.onEnd();
            return;
          }
          const bg = state.songs?.background;
          if (bg) {
            startAudio(bg, {loop:true});
          }
        };
        player.src = url;
        if (fadeIn) {
          let vol = 0.0;
          player.volume = 0;
          player.play();
          const steps = 10;
          const stepMs = 50;
          const inc = 1/steps;
          let count = 0;
          const intv = setInterval(()=>{
            count += 1;
            vol = Math.min(1, vol + inc);
            player.volume = vol;
            if (count >= steps) clearInterval(intv);
          }, stepMs);
        } else {
          player.volume = 1;
          player.play();
        }
      };
      // only fade out on normal transitions; skip fading when interrupting (opts.skipFadeOut)
      if (fadeOut && !opts.skipFadeOut && !player.paused && player.src) {
        let vol = player.volume;
        const steps = 10;
        const stepMs = 50;
        const dec = vol/steps;
        let count = 0;
        const outv = setInterval(()=>{
          count += 1;
          vol = Math.max(0, vol - dec);
          player.volume = vol;
          if (count >= steps) {
            clearInterval(outv);
            player.pause();
            doPlay();
          }
        }, stepMs);
      } else {
        doPlay();
      }
    }

    function getRoleUrl(role) {
      const lib = state.songs?.library || {};
      for (const key of Object.keys(lib)) {
        const roles = lib[key].roles || [];
        if (roles.includes(role)) return lib[key].url;
      }
      return null;
    }

    function ensureBackground() {
      const lib = state.songs?.library || {};
      const bgExplicit = state.songs?.background;
      let bg = bgExplicit;
      if (!bg) {
        bg = getRoleUrl("background");
        if (bg) {
          api("/songs/play", {method:"POST", body:{target:"background", url:bg}});
          state.songs = state.songs || {};
          state.songs.background = bg;
          state.songs.current = state.songs.current || bg;
        }
      }
      if (bg) {
        startAudio(bg, {loop:true});
      }
    }

    function pickRandom(arr) {
      if (!arr?.length) return null;
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function tickPoints() {
      if (!routine.active || !routine.startTime || !routine.endTime) return;
      const now = Date.now();
      const remaining = routine.endTime - now;
      if (remaining <= 0) {
        stopPointsInterval();
        return;
      }
      const scores = state.scores || {slot_one:0, slot_two:0};
      const a = scores.slot_one || 0;
      const b = scores.slot_two || 0;
      const totalPts = Math.max(1, a + b);
      const mean = Math.max(1, Math.round(totalPts * 0.05)); // 5% of current total points
      let amount = Math.max(1, Math.round(Math.random() * mean) + 1);
      let slot = Math.random() < 0.5 ? "slot_one" : "slot_two";
      const diff = (scores.slot_one||0) - (scores.slot_two||0);
      const losing = diff > 0 ? "slot_two" : diff < 0 ? "slot_one" : null;
      if (losing && Math.random() < 0.05) { // comeback chance
        slot = losing;
        amount += Math.round(mean * 30);
      }
      api(`/score/${slot}/add`, {method:"POST", body:{amount}}).then(refreshState);
    }

    function getEnabledDancers() {
      const enabled = state.enabled_dancers || [];
      const set = new Set((enabled || []).map(x => (x || "").toLowerCase()));
      const pool = state.dancers || [];
      if (!enabled.length) return pool;
      return pool.filter(d => set.has((d.name || "").toLowerCase()));
    }

    function chooseTwoDancers() {
      const dancers = getEnabledDancers();
      if (dancers.length < 2) return ["Dancer A", "Dancer B"];
      const last = (state.last_winner || "").toLowerCase();
      const match = dancers.find(d => (d.name||"").toLowerCase() === last);
      const others = dancers.filter(d => d !== match);
      const pickOther = others.length ? others[Math.floor(Math.random()*others.length)] : null;
      if (match && pickOther) {
        return [match.name || "Dancer A", pickOther.name || "Dancer B"];
      }
      const shuffled = [...dancers].sort(()=>Math.random()-0.5);
      return [shuffled[0].name || "Dancer A", shuffled[1].name || "Dancer B"];
    }

    function songsForDancer(name) {
      const lib = state.songs?.library || {};
      const target = (name||"").toLowerCase();
      return Object.values(lib).filter(s => {
        const dancers = (s.dancers||[]).map(x=>x.toLowerCase());
        const knows = (s.knows_song||[]).map(x=>x.toLowerCase());
        return dancers.includes(target) || knows.includes(target);
      });
    }

    function intersectSongsFor(a, b) {
      const listA = new Set(songsForDancer(a).map(s => s.url));
      return songsForDancer(b).filter(s => listA.has(s.url));
    }

    function groupSongs() {
      const group = (state.group_name || "").toLowerCase();
      const lib = state.songs?.library || {};
      return Object.values(lib).filter(s => {
        const dancers = (s.dancers||[]).map(x=>x.toLowerCase());
        const knows = (s.knows_song||[]).map(x=>x.toLowerCase());
        return group && (dancers.includes(group) || knows.includes(group));
      });
    }

    function pickSongFor(name, excludeUrl=null) {
      const pool = songsForDancer(name).filter(s => !(s.roles||[]).some(r=>SPECIAL_ROLES.includes(r)));
      const filtered = excludeUrl ? pool.filter(s => s.url !== excludeUrl) : pool;
      const chosen = pickRandom(filtered.length ? filtered : pool);
      return chosen ? chosen.url : null;
    }

    function getLeaderName() {
      const scores = state.scores || {slot_one:0, slot_two:0};
      const a = scores.slot_one || 0;
      const b = scores.slot_two || 0;
      if (a > b) return state.slot_one || "";
      if (b > a) return state.slot_two || "";
      return "";
    }

    function nextSongFor(dancerA, dancerB, excludeUrl=null) {
      const pool = [...songsForDancer(dancerA), ...songsForDancer(dancerB)].filter(s => !(s.roles||[]).some(r=>SPECIAL_ROLES.includes(r)));
      const filtered = pool.filter(s => s.url !== excludeUrl);
      const chosen = pickRandom(filtered.length ? filtered : pool);
      return chosen ? chosen.url : null;
    }

    function clearRoutineTimers() {
      routine.timers.forEach(t=>clearTimeout(t));
      routine.timers = [];
    }

    function stopTimerInterval() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    function startPointsInterval() {
      stopPointsInterval();
      routine.pointsInterval = setInterval(tickPoints, 1000);
    }

    function stopPointsInterval() {
      if (routine.pointsInterval) {
        clearInterval(routine.pointsInterval);
        routine.pointsInterval = null;
      }
    }

    function stopSwitchInterval() {
      if (routine.switchInterval) {
        clearInterval(routine.switchInterval);
        routine.switchInterval = null;
      }
    }

    function startRoutine() {
      clearRoutineTimers();
      routine.active = true;
      routine.startTime = Date.now();
      routine.endTime = routine.startTime + 120000; // 2 minutes
      routine.dancers = chooseTwoDancers();
      routine.firstSongPlayed = false;
      routine.warned = false;
      startPointsInterval();
      setCenterLine(true);
      api("/battle/start", {method:"POST", body:{}}).then(()=> {
        api("/battle/slot/slot_one", {method:"POST", body:{slot_one: routine.dancers[0], slot_two: routine.dancers[1]}}).catch(()=>{});
        api("/battle/slot/slot_two", {method:"POST", body:{slot_one: routine.dancers[0], slot_two: routine.dancers[1]}}).catch(()=>{});
        saveWinnerValue(routine.dancers[0]); // pre-fill last winner with first dancer for convenience
      });
      playRoutineSong(null);
      renderTimer(true);
      renderWinnerSelect();
    }

    function cancelRoutine() {
      routine.active = false;
      routine.warned = false;
      clearRoutineTimers();
      stopPointsInterval();
      stopSwitchInterval();
      const player = document.getElementById("player");
      try { player.pause(); } catch(e){}
      ensureBackground();
      stopTimerInterval();
      setCenterLine(false);
      renderTimer(true);
    }

    function playRoutineSong(lastUrl) {
      if (!routine.active) return;
      const now = Date.now();
      const remaining = routine.endTime - now;
      if (remaining <= 0) {
        playSequence(["applause","win"], true);
        routine.active = false;
        stopPointsInterval();
        stopSwitchInterval();
        evaluateWinner();
        return;
      }
      if (remaining <= 30000) {
        // stop current audio
        const player = document.getElementById("player");
        try { player.pause(); } catch(e){}
        setCenterLine(false);
        stopSwitchInterval();
        playSequence(["applause","attention"], false, () => {
          const wait = Math.max(0, routine.endTime - Date.now());
          const t = setTimeout(() => playRoutineSong(null), wait);
          routine.timers.push(t);
        });
        return;
      }
      let url = nextSongFor(routine.dancers[0], routine.dancers[1], lastUrl);
      if (routine.firstSongPlayed) {
        const leader = getLeaderName();
        if (leader) {
          const leaderSong = pickSongFor(leader, lastUrl);
          if (leaderSong) url = leaderSong;
        }
      }
      if (!routine.firstSongPlayed) {
        const both = intersectSongsFor(routine.dancers[0], routine.dancers[1]);
        const filteredBoth = both.filter(s => !(s.roles||[]).some(r=>SPECIAL_ROLES.includes(r)));
        const pickBoth = pickRandom(filteredBoth.length ? filteredBoth : both);
        if (pickBoth) {
          url = pickBoth.url;
        } else {
          const groupList = groupSongs().filter(s => !(s.roles||[]).some(r=>SPECIAL_ROLES.includes(r)));
          const pickGroup = pickRandom(groupList.length ? groupList : groupSongs());
          if (pickGroup) url = pickGroup.url;
        }
      }
      if (!url) url = getRoleUrl("background");
      if (!url) { ensureBackground(); return; }
      const afterDoorbell = () => {
        api("/songs/play", {method:"POST", body:{target:"group", url}}).catch(()=>{});
        if (!state.songs) state.songs = {};
        state.songs.current = url;
        routine.currentSongOwner = routine.firstSongPlayed ? getLeaderName() : "";
        routine.currentSongUrl = url;
        stopSwitchInterval();
        routine.switchInterval = setInterval(() => monitorSongSwitch(), 2000);
        startAudio(url, {loop:false, onEnd: () => {
          playSequence(["bell"], false, () => playRoutineSong(url));
        }});
      };
      if (!routine.firstSongPlayed) {
        routine.firstSongPlayed = true;
        playSequence(["bell"], false, afterDoorbell);
      } else {
        afterDoorbell();
      }
    }

    function playSequence(roleNames, loopLast=false, onDone=null) {
      const [first, ...rest] = roleNames;
      const url = getRoleUrl(first);
      if (!url) { if (rest.length) return playSequence(rest, loopLast, onDone); if (onDone) onDone(); return; }
      startAudio(url, {loop: loopLast && rest.length===0, onEnd: () => {
        if (!rest.length) { if (onDone) onDone(); return; }
        playSequence(rest, loopLast, onDone);
      }});
    }

    function setCenterLine(show) {
      api(`/overlay/${CENTER_LINE}/${show ? "show" : "hide"}`, {method:"POST"}).catch(()=>{});
      if (state.overlay_states) state.overlay_states[CENTER_LINE] = show;
    }

    function saveWinnerValue(name) {
      api("/battle/winner", {method:"POST", body:{name}});
      const sel = document.getElementById("winnerSelect");
      if (sel) sel.value = name;
    }

    function saveWinnerSelect() {
      const sel = document.getElementById("winnerSelect");
      if (!sel) return;
      saveWinnerValue(sel.value);
    }

    function saveGroupValue(name) {
      api("/battle/group", {method:"POST", body:{name}});
      const sel = document.getElementById("groupSelect");
      if (sel) sel.value = name;
    }

    function saveGroupSelect() {
      const sel = document.getElementById("groupSelect");
      if (!sel) return;
      saveGroupValue(sel.value);
      renderSongs();
    }

    function toggleEnabledDancer(name, enabled) {
      const list = new Set(state.enabled_dancers || []);
      if (enabled) list.add(name); else list.delete(name);
      const arr = Array.from(list);
      api("/dancers/enabled", {method:"POST", body:{names: arr}});
      state.enabled_dancers = arr;
      renderWinnerSelect();
      renderGroupSelect();
      renderSongs();
    }

    function evaluateWinner() {
      const scores = state.scores || {slot_one:0, slot_two:0};
      const a = scores.slot_one || 0;
      const b = scores.slot_two || 0;
      if (a === b) return;
      const winnerName = a > b ? (state.slot_one || "") : (state.slot_two || "");
      const target = winnerName || (a > b ? "slot_one" : "slot_two");
      api("/battle/win", {method:"POST", body:{name: target}});
      if (winnerName) saveWinnerValue(winnerName);
      refreshState();
    }

    function monitorSongSwitch() {
      if (!routine.active || !routine.currentSongUrl) return;
      if (!routine.currentSongOwner) return;
      const scores = state.scores || {slot_one:0, slot_two:0};
      const a = scores.slot_one || 0;
      const b = scores.slot_two || 0;
      const leaderSlot = a > b ? "slot_one" : b > a ? "slot_two" : null;
      if (!leaderSlot) return;
      const leaderName = leaderSlot === "slot_one" ? (state.slot_one || "") : (state.slot_two || "");
      const loserScore = leaderSlot === "slot_one" ? b : a;
      const leaderScore = leaderSlot === "slot_one" ? a : b;
      if (!leaderName || leaderName === routine.currentSongOwner) return;
      if (loserScore <= 0) return;
      if (leaderScore < loserScore * 1.67) return; // needs 67% margin
      const leaderKnows = songsForDancer(leaderName).some(s => s.url === routine.currentSongUrl);
      const otherName = leaderSlot === "slot_one" ? (state.slot_two || "") : (state.slot_one || "");
      const otherKnows = songsForDancer(otherName).some(s => s.url === routine.currentSongUrl);
      // do not interrupt if both know the song or if it's a group song
      const isGroupSong = groupSongs().some(s => s.url === routine.currentSongUrl);
      if (leaderKnows && otherKnows) return;
      if (isGroupSong) return;
      const newUrl = pickSongFor(leaderName, routine.currentSongUrl) || getRoleUrl("background");
      if (!newUrl) return;
      routine.currentSongOwner = leaderName;
      routine.currentSongUrl = newUrl;
      api("/songs/play", {method:"POST", body:{target:"group", url:newUrl}}).catch(()=>{});
      playSequence(["bell"], false, () => {
        startAudio(newUrl, {skipFadeOut:true, loop:false, onEnd: () => {
          playSequence(["bell"], false, () => playRoutineSong(newUrl));
        }});
      });
    }

    function renderTimer(force=false) {
      const el = document.getElementById("timerDisplay");
      if (!el) return;
      const update = () => {
        if (!routine.active || !routine.endTime) {
          el.textContent = "-";
          el.style.color = "#e2e8f0";
          stopTimerInterval();
          return;
        }
        const remaining = Math.max(0, Math.ceil((routine.endTime - Date.now()) / 1000));
        const mins = String(Math.floor(remaining / 60)).padStart(2,"0");
        const secs = String(remaining % 60).padStart(2,"0");
        el.textContent = `${mins}:${secs}`;
       el.style.color = remaining <= 30 ? "#ef4444" : "#e2e8f0";
       if (remaining <= 30 && remaining > 0 && !routine.warned) {
         // once under 30s, stop current and force applause->attention
         const player = document.getElementById("player");
         try { player.pause(); } catch(e){}
         playSequence(["applause","attention"], false);
         routine.warned = true;
         setCenterLine(false);
         stopSwitchInterval();
       }
       if (remaining <= 0) {
         routine.active = false;
         routine.warned = false;
         stopTimerInterval();
          stopPointsInterval();
          const player = document.getElementById("player");
          try { player.pause(); } catch(e){}
          evaluateWinner();
          playSequence(["applause","win"], true);
        }
      };
      if (!timerInterval || force) {
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(update, 1000);
      }
      update();
    }


    async function refreshCameras() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        // Only list physical/non-virtual cams for feeding into the virtual cam
        const cams = devices.filter(d => d.kind === "videoinput" && !/virtual/i.test(d.label || ""));
        const select = document.getElementById("cameraSelect");
        select.innerHTML = "";
        cams.forEach((cam, idx) => {
          const opt = document.createElement("option");
          opt.value = cam.deviceId || "";
          opt.dataset.idx = idx;
          opt.dataset.label = cam.label || `Camera ${idx}`;
          opt.textContent = cam.label || `Camera ${idx}`;
          select.appendChild(opt);
        });
        if (!select.value && cams[0]) select.value = cams[0].deviceId;
      } catch (e) {
        console.warn("Camera enumeration failed", e);
      }
    }

    async function startPreview() {
      const video = document.getElementById("preview");
      if (!navigator.mediaDevices?.getUserMedia) return alert("getUserMedia not supported");
      try {
        await applyCamera();
        // Always preview the virtual camera; fall back to first device
        const refreshed = await navigator.mediaDevices.enumerateDevices();
        const vcams = refreshed.filter(d => d.kind === "videoinput");
        const virtualTarget = vcams.find(c => /virtual/i.test(c.label || "")) || vcams[0];
        if (!virtualTarget) return alert("No camera found");
        const constraints = virtualTarget.deviceId ? { deviceId: { exact: virtualTarget.deviceId } } : true;
        const stream = await navigator.mediaDevices.getUserMedia({ video: constraints });
        video.srcObject = stream;
        await video.play();
      } catch (err) {
        alert("Camera access denied or unavailable: " + err);
      }
    }

    function applyCamera() {
      const select = document.getElementById("cameraSelect");
      const idx = Number(select.selectedOptions[0]?.dataset.idx ?? 0);
      const label = select.selectedOptions[0]?.dataset.label || "";
      return api("/camera/select", {method:"POST", body:{index: idx, label}}).then(()=>refreshState());
    }

    // Initial camera list load
    refreshCameras();

    // WebSocket live updates
    const ws = new WebSocket((location.origin.replace(/^http/,"ws")) + "/ws/state");
    ws.onopen = () => { document.getElementById("wsDot").style.background = "#22c55e"; document.getElementById("statusText").textContent = "Live"; };
    ws.onclose = () => { document.getElementById("wsDot").style.background = "#ef4444"; document.getElementById("statusText").textContent = "Disconnected"; setTimeout(()=>location.reload(), 2000); };
    ws.onmessage = evt => { try { const data = JSON.parse(evt.data); if(data.type==="state"){ state = data.payload; renderState(); }} catch(e){} };

    refreshState();
    refreshSongs();
  </script>
</body>
</html>
