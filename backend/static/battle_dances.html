<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Battle Control</title>
  <style>
    body { font-family: "Segoe UI", Arial, sans-serif; margin: 0; background: #0f172a; color: #e2e8f0; }
    header { padding: 16px 24px; background: #1e293b; box-shadow: 0 2px 6px rgba(0,0,0,.3); display: flex; align-items: center; justify-content: space-between; }
    h1 { margin: 0; font-size: 20px; }
    main { padding: 20px 24px; display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    section { background: #111827; border: 1px solid #1f2937; border-radius: 10px; padding: 16px; box-shadow: inset 0 1px 0 rgba(255,255,255,.02); }
    h2 { margin-top: 0; font-size: 16px; letter-spacing: 0.02em; }
    .row { display: flex; gap: 8px; margin-bottom: 10px; }
    button { cursor: pointer; background: #2563eb; color: #fff; border: none; border-radius: 6px; padding: 8px 12px; font-weight: 600; }
    button.secondary { background: #334155; }
    button.danger { background: #ef4444; }
    input, select { padding: 8px; border-radius: 6px; border: 1px solid #334155; background: #0b1222; color: #e2e8f0; }
    ul { list-style: none; padding: 0; margin: 0; max-height: 220px; overflow: auto; }
    li { padding: 8px; border-bottom: 1px solid #1f2937; display: flex; justify-content: space-between; align-items: center; }
    .badge { padding: 4px 8px; border-radius: 6px; background: #1e293b; font-size: 12px; }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .status { display: inline-flex; align-items: center; gap: 6px; font-weight: 700; text-transform: uppercase; }
    .dot { width: 10px; height: 10px; border-radius: 50%; background: #22c55e; }
    table { width: 100%; border-collapse: collapse; }
    td { padding: 6px 4px; border-bottom: 1px solid #1f2937; }
    .overlay-toggle { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; padding: 6px 8px; background: #0b1222; border-radius: 6px; }
    .bar-wrap { width: 100%; height: 18px; background: #0b1222; border: 1px solid #1f2937; border-radius: 10px; overflow: hidden; display: flex; }
    .bar-left { background: #ef4444; height: 100%; }
    .bar-right { background: #3b82f6; height: 100%; }
    .leader1 { background: #7f1d1d; color:#fef2f2; border-radius: 6px; padding: 4px 6px; }
    .leader2 { background: #1d4ed8; color:#eff6ff; border-radius: 6px; padding: 4px 6px; }
    .secondary.active { background:#22c55e; color:#0b1222; }
    .hint { position: relative; display:flex; flex:1; }
    .hint-text { position:absolute; top:-28px; left:0; background:#111827; border:1px solid #1f2937; padding:4px 8px; border-radius:6px; font-size:12px; white-space:nowrap; opacity:0; visibility:hidden; transition:opacity .1s; z-index:10; }
    .hint:hover .hint-text { opacity:1; visibility:visible; }
    .nav-bar a.active { font-weight:700; }
  </style>
</head>
<body>
  <nav class="nav-bar" style="background:#0b1222;border-bottom:1px solid #1f2937;padding:10px 16px;display:flex;gap:10px;position:sticky;top:0;z-index:5;">
    <a href="/group/dances" style="color:#e2e8f0;text-decoration:none;">Group Dances</a>
    <a href="/battle/dances" style="color:#e2e8f0;text-decoration:none;">Battle Control</a>
    <a href="/dances/menu" style="color:#e2e8f0;text-decoration:none;">Dance Menu</a>
    <a href="/dancers/register" style="color:#e2e8f0;text-decoration:none;">Dancers</a>
    <a href="/songs/edit" style="color:#e2e8f0;text-decoration:none;">Songs</a>
    <a href="/audio/tools" style="color:#e2e8f0;text-decoration:none;">Audio Tools</a>
  </nav>
  <header>
    <div style="display:flex;align-items:center;gap:10px;">
      <span id="wsDot" style="display:inline-flex;align-items:center;justify-content:center;width:10px;height:10px;border-radius:50%;background:#ef4444;box-shadow:0 0 8px #ef4444;"></span>
      <h1>TikTok Battle Control</h1>
    </div>
    <div style="display:flex;align-items:center;gap:8px;">
      <div class="status"><span id="statusText">Connecting</span></div>
      <div id="current"></div>
    </div>
  </header>
  <main>
    <section>
      <h2>Battle</h2>
      <div class="row">
        <button class="secondary" onclick="startRoutine()">Simulate 2m Battle Routine</button>
        <button class="danger" onclick="cancelRoutine()">Cancel Routine</button>
      </div>
      <div class="row">
        <button class="secondary" onclick="playRole('mvp')">Play MVP Dance</button>
      </div>
      <div class="row">
        <button class="secondary" onclick="skipSong()">Skip to Next Song</button>
      </div>
      <div class="row" style="align-items:center;">
        <select id="nextPairSelect" style="flex:1;">
          <option value="">(choose next dancer or leave random)</option>
        </select>
      </div>
      <div class="row" style="align-items:center;">
        <span id="nextPairLabel" style="font-weight:700;">Next pair: -</span>
      </div>
      <div class="row">
        <span>Timer: <strong id="timerDisplay">-</strong></span>
      </div>
      <div class="row">
        <label style="display:flex;gap:6px;align-items:center; width:100%;">
          <span style="white-space:nowrap;">Last winner:</span>
          <select id="winnerSelect" style="flex:1;" onchange="saveWinnerSelect()"></select>
        </label>
      </div>
      <div class="row">
        <label style="display:flex;gap:6px;align-items:center; width:100%;">
          <span style="white-space:nowrap;">Current group:</span>
          <select id="groupSelect" style="flex:1;" onchange="saveGroupSelect()"></select>
        </label>
      </div>
      <div class="row" id="enabledDancers"></div>
      <div class="row" id="winsEditor" style="flex-wrap:wrap; gap:8px;"></div>
      <table>
        <tr><td>Slot One</td><td id="slotOneCell">-</td></tr>
        <tr><td>Slot Two</td><td id="slotTwoCell">-</td></tr>
        <tr><td>Points</td><td>
          <div class="bar-wrap"><div id="barLeft" class="bar-left" style="width:50%"></div><div id="barRight" class="bar-right" style="width:50%"></div></div>
          <div class="row" style="margin-top:4px; gap:12px;">
            <span id="pointsLeftLabel">0</span>
            <span id="pointsRightLabel" style="margin-left:auto;">0</span>
          </div>
        </td></tr>
      </table>
      <div class="row">
        <button class="secondary" onclick="pullFromStudio()">Sync from TikTok Studio</button>
      </div>
    </section>

    <section>
      <h2>Overlays</h2>
      <div id="overlays"></div>
    </section>

    <section>
      <h2>Music Control</h2>
      <div class="row">
        <button class="secondary" id="tabGroup" onclick="selectTab('group')">Group</button>
        <button class="secondary" id="tabOne" onclick="selectTab('slot_one')">Dancer 1</button>
        <button class="secondary" id="tabTwo" onclick="selectTab('slot_two')">Dancer 2</button>
        <button class="secondary" id="tabIntersect" onclick="selectTab('intersect')">Intersect</button>
      </div>
      <div class="row">
        <div class="hint">
          <span class="hint-text">Type to filter; select to play</span>
          <input id="songFilter" placeholder="Search songs" style="flex:1;" list="songSuggestions" oninput="renderSongs()" onchange="filterSelected()">
        </div>
        <datalist id="songSuggestions"></datalist>
      </div>
      <div class="row">
        <select id="songSelect" style="flex:1;"></select>
        <button onclick="playSong()">Play Song</button>
      </div>
      <div class="row" style="align-items:center;">
        <label style="display:flex;gap:6px;align-items:center;">
          <input type="checkbox" id="fadeToggle" checked> Fade in 0.5s
        </label>
        <label style="display:flex;gap:6px;align-items:center;">
          <input type="checkbox" id="fadeOutToggle" checked> Fade out 0.5s
        </label>
      </div>
      <div class="row">
        <span>Current song: <span id="currentSongLabel">-</span></span>
      </div>
      <audio id="player" preload="auto" controls style="width:100%;" loop></audio>
      <audio id="applause" preload="auto" src="https://actions.google.com/sounds/v1/crowds/applause_small_group.ogg"></audio>
    </section>

    <section>
      <h2>Virtual Cam Preview</h2>
      <div class="row">
        <select id="cameraSelect" style="flex:1;"></select>
        <button class="secondary" onclick="refreshCameras()">Refresh Cameras</button>
      </div>
      <div class="row">
        <button class="secondary" onclick="startPreview()">Start Preview</button>
      </div>
      <video id="preview" width="100%" autoplay playsinline style="background:#0b1222;border:1px solid #1f2937;border-radius:8px;"></video>
    </section>
  </main>

  <script>
    const api = (path, opts={}) => fetch(path, {method: opts.method||"GET", headers: {"Content-Type":"application/json"}, body: opts.body ? JSON.stringify(opts.body) : undefined});
    let state = {};
    let currentTab = "";
    let routine = { active:false, timers:[], endTime:0, startTime:0, dancers:[], firstSongPlayed:false, warned:false, pointsInterval:null, switchInterval:null, currentSongOwner:"", currentSongUrl:"", playedSongs:new Set() };
    let timerInterval = null;
    const SPECIAL_ROLES = ["bell","applause","attention","background","win"];
    let playCounts = loadPlayCounts();
    let lastSongUrl = loadLastSong();
    const CENTER_LINE = "CenterDottedLine";
    let nextPairOverride = null;

    function highlightNav() {
      const here = location.pathname.replace(/\/+$/,"") || "/";
      document.querySelectorAll(".nav-bar a").forEach(a => {
        const link = (a.getAttribute("href") || "").replace(/\/+$/,"") || "/";
        if (link === here) a.classList.add("active"); else a.classList.remove("active");
      });
    }

    function loadPlayCounts() {
      try {
        const raw = localStorage.getItem("playCounts");
        return raw ? JSON.parse(raw) : {};
      } catch (e) {
        return {};
      }
    }
    function savePlayCounts() {
      try { localStorage.setItem("playCounts", JSON.stringify(playCounts)); } catch (e) {}
    }
    function loadLastSong() {
      try { return localStorage.getItem("lastSongUrl") || ""; } catch (e) { return ""; }
    }
    function saveLastSong(url) {
      lastSongUrl = url || "";
      try { localStorage.setItem("lastSongUrl", lastSongUrl); } catch (e) {}
    }
    function notePlay(url) {
      if (!url || SPECIAL_ROLES.includes(url)) return;
      playCounts[url] = (playCounts[url] || 0) + 1;
      savePlayCounts();
      saveLastSong(url);
    }

    function renderState() {
      const slotOne = state.slot_one || "-";
      const slotTwo = state.slot_two || "-";
      const scores = state.scores || {slot_one:0, slot_two:0};
      const a = scores.slot_one || 0;
      const b = scores.slot_two || 0;
      const slotOneCell = document.getElementById("slotOneCell");
      const slotTwoCell = document.getElementById("slotTwoCell");
      slotOneCell.textContent = slotOne;
      slotTwoCell.textContent = slotTwo;
      slotOneCell.classList.remove("leader","leader1","leader2");
      slotTwoCell.classList.remove("leader","leader1","leader2");
      if (a === b && a > 0) {
        slotOneCell.classList.add("leader1");
        slotTwoCell.classList.add("leader2");
      } else if (a > b) {
        slotOneCell.classList.add("leader1");
      } else if (b > a) {
        slotTwoCell.classList.add("leader2");
      }
      renderPointsBar();
      renderWinnerSelect();
      renderGroupSelect();
      renderEnabledDancers();
      renderWinsEditor();
      renderOverlays();
      renderSongs();
      renderTimer();
    }

    function renderPointsBar() {
      const scores = state.scores || {slot_one:0, slot_two:0};
      const a = scores.slot_one || 0;
      const b = scores.slot_two || 0;
      const total = Math.max(1, a + b);
      const leftPct = Math.round((a / total) * 100);
      const rightPct = 100 - leftPct;
      const leftEl = document.getElementById("barLeft");
      const rightEl = document.getElementById("barRight");
      const leftLabel = document.getElementById("pointsLeftLabel");
      const rightLabel = document.getElementById("pointsRightLabel");
      if (leftEl) leftEl.style.width = `${leftPct}%`;
      if (rightEl) rightEl.style.width = `${rightPct}%`;
      if (leftLabel) leftLabel.textContent = a;
      if (rightLabel) rightLabel.textContent = b;
    }

    function renderOverlays() {
      const wrap = document.getElementById("overlays");
      wrap.innerHTML = "";
      const overlays = state.overlay_states || {};
      if (!routine.active && overlays[CENTER_LINE]) {
        setCenterLine(false);
        overlays[CENTER_LINE] = false;
      }
      Object.keys(overlays).forEach(name => {
        const row = document.createElement("div");
        row.className = "overlay-toggle";
        row.innerHTML = `<span>${name}</span>`;
        const btn = document.createElement("button");
        btn.textContent = overlays[name] ? "Hide" : "Show";
        btn.onclick = () => toggleOverlay(name, !overlays[name]);
        row.appendChild(btn);
        wrap.appendChild(row);
      });
    }

    function renderWinnerSelect() {
      const sel = document.getElementById("winnerSelect");
      if (!sel) return;
      sel.innerHTML = "";
      const current = (state.last_winner || "").toLowerCase();
      const opts = [];
      const enabled = state.enabled_dancers || [];
      const enabledSet = new Set(enabled.map(x=>x.toLowerCase()));
      (state.dancers || []).forEach(d => {
        const name = d.name || "";
        if (!name) return;
        if (enabled.length && !enabledSet.has(name.toLowerCase())) return;
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        if (name.toLowerCase() === current) opt.selected = true;
        opts.push(opt);
      });
      // add empty option
      const empty = document.createElement("option");
      empty.value = "";
      empty.textContent = "(none)";
      sel.appendChild(empty);
      opts.forEach(o => sel.appendChild(o));
      if (current && !sel.value) sel.value = current;
      renderNextPairOptions();
    }

    function renderGroupSelect() {
      const sel = document.getElementById("groupSelect");
      if (!sel) return;
      sel.innerHTML = "";
      const current = (state.group_name || "").toLowerCase();
      const opts = [];
      const enabled = state.enabled_dancers || [];
      const enabledSet = new Set(enabled.map(x=>x.toLowerCase()));
      (state.dancers || []).forEach(d => {
        const name = d.name || "";
        if (!name) return;
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        if (name.toLowerCase() === current) opt.selected = true;
        opts.push(opt);
      });
      const empty = document.createElement("option");
      empty.value = "";
      empty.textContent = "(none)";
      sel.appendChild(empty);
      opts.forEach(o => sel.appendChild(o));
      if (current && !sel.value) sel.value = current;
      renderNextPairOptions();
    }

    function renderEnabledDancers() {
      const container = document.getElementById("enabledDancers");
      if (!container) return;
      container.innerHTML = "";
      const enabled = new Set((state.enabled_dancers || []).map(x => (x||"").toLowerCase()));
      (state.dancers || []).forEach(d => {
        const name = d.name || "";
        if (!name) return;
        const wrap = document.createElement("label");
        wrap.style.display = "flex";
        wrap.style.alignItems = "center";
        wrap.style.gap = "6px";
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = enabled.has(name.toLowerCase());
        cb.onchange = () => toggleEnabledDancer(name, cb.checked);
        const span = document.createElement("span");
        span.textContent = name;
        wrap.appendChild(cb);
        wrap.appendChild(span);
        container.appendChild(wrap);
      });
      renderNextPairOptions();
    }

    function renderNextPairOptions() {
      const sel = document.getElementById("nextPairSelect");
      if (!sel) return;
      const currentVal = sel.value;
      const enabled = state.enabled_dancers || [];
      const dancers = state.dancers || [];
      sel.innerHTML = "";
      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "(choose next dancer or leave random)";
      sel.appendChild(placeholder);
      const enabledSet = new Set(enabled.map(x => (x||"").toLowerCase()));
      dancers.forEach(d => {
        const name = d.name || "";
        if (!name) return;
        if (enabled.length && !enabledSet.has(name.toLowerCase())) return;
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        sel.appendChild(opt);
      });
      if (currentVal) {
        const match = Array.from(sel.options).find(o => (o.value || "").toLowerCase() === currentVal.toLowerCase());
        if (match) sel.value = match.value;
      }
      sel.onchange = () => pickNextPair();
    }

    function renderWinsEditor() {
      const container = document.getElementById("winsEditor");
      if (!container) return;
      container.innerHTML = "";
      const wins = state.win_counts || {};
      const enabled = new Set((state.enabled_dancers || []).map(x => (x||"").toLowerCase()));
      (state.dancers || []).forEach(d => {
        const name = d.name || "";
        if (!name) return;
        if (enabled.size && !enabled.has(name.toLowerCase())) return;
        const wrap = document.createElement("div");
        wrap.style.display = "flex";
        wrap.style.alignItems = "center";
        wrap.style.gap = "4px";
        const label = document.createElement("span");
        label.textContent = name;
        const input = document.createElement("input");
        input.type = "number";
        input.min = "0";
        input.value = wins[name] || 0;
        input.style.width = "70px";
        const btn = document.createElement("button");
        btn.textContent = "Save";
        btn.onclick = () => {
          const val = parseInt(input.value, 10);
          api("/battle/win", {method:"POST", body:{name, wins: isNaN(val)?0:val}}).then(refreshState);
        };
        wrap.appendChild(label);
        wrap.appendChild(input);
        wrap.appendChild(btn);
        container.appendChild(wrap);
      });
      renderNextPairOptions();
    }

    function refreshState() {
      api("/state").then(r => r.json()).then(s => { state = s; renderState(); renderGroupSelect(); renderWinnerSelect(); });
    }

    function startBattle() {
      routine.active = false;
      clearRoutineTimers();
      setCenterLine(false);
      api("/battle/start", {method:"POST", body:{}}).then(refreshState);
    }
    function endBattle() {
      routine.active = false;
      clearRoutineTimers();
      api("/battle/end", {method:"POST"}).then(refreshState);
    }
    function addScore(slot) { api(`/score/${slot}/add`, {method:"POST", body:{amount:1}}).then(refreshState); }
    function pullFromStudio() {
      // External automation should POST to /battle/slots/import; this button just refreshes state.
      refreshState();
    }
    function toggleOverlay(name, show) { api(`/overlay/${name}/${show?"show":"hide"}`, {method:"POST"}).then(refreshState); }

    function selectTab(tab) {
      // toggle off if clicking the active tab
      if (currentTab === tab) {
        currentTab = "";
      } else {
        currentTab = tab;
      }
      ["tabGroup","tabOne","tabTwo","tabIntersect"].forEach(id=>{
        const el = document.getElementById(id);
        if (!el) return;
        const isActive = (id==="tabGroup" && tab==="group")
          || (id==="tabOne" && tab==="slot_one")
          || (id==="tabTwo" && tab==="slot_two")
          || (id==="tabIntersect" && tab==="intersect");
        const shouldActive = isActive && currentTab === tab;
        el.className = shouldActive ? "secondary active" : "secondary";
        if (shouldActive) {
          el.focus();
        }
      });
      renderSongs();
    }

    function renderSongs() {
      const songs = state.songs || {};
      const lib = songs.library || {};
      const currentUrl = songs.current || "";
      const backgroundUrl = songs.background || "";
      const filter = (document.getElementById("songFilter").value || "").toLowerCase();
      const tabFilter = currentTab === "slot_one" ? (state.slot_one || "").toLowerCase()
                     : currentTab === "slot_two" ? (state.slot_two || "").toLowerCase()
                     : currentTab === "group" ? (state.group_name || "").toLowerCase()
                     : currentTab === "intersect" ? "intersect"
                     : "";
      const datalist = document.getElementById("songSuggestions");
      const filterFocused = document.activeElement && document.activeElement.id === "songFilter";
      if (!filterFocused) datalist.innerHTML = "";
      let currentName = "-";
      const tryResolve = (url) => {
        let name = "-";
        Object.values(lib).forEach(item => {
          if (item.url === url) {
            name = item.name || url;
          }
        });
        if (name === "-" && url && url === backgroundUrl) {
          name = "Background";
        }
        if (name === "-" && url) name = url;
        return name;
      };
      if (currentUrl) {
        currentName = tryResolve(currentUrl);
      } else if (backgroundUrl) {
        currentName = tryResolve(backgroundUrl);
      }
      document.getElementById("currentSongLabel").textContent = currentName;
      const select = document.getElementById("songSelect");
      select.innerHTML = "";
      Object.keys(lib).forEach(key => {
        const opt = document.createElement("option");
        opt.value = lib[key].url;
        let label = lib[key].name || key;
        const fronts = (lib[key].front_dancers || []).join(", ");
        if (fronts) {
          label += ` (Front: ${fronts})`;
        }
        opt.textContent = label;
        let matches = (!filter || label.toLowerCase().includes(filter));
        if (tabFilter && tabFilter !== "intersect") {
          matches = matches && (lib[key].dancers || []).some(d => (d || "").toLowerCase().includes(tabFilter));
        }
        if (tabFilter === "intersect") {
          if (state.slot_one && state.slot_two) {
            const both = intersectSongsFor(state.slot_one, state.slot_two).map(s => s.url);
            matches = matches && both.includes(lib[key].url);
          } else {
            matches = false;
          }
        }
        if (matches) {
          select.appendChild(opt);
          if (!filterFocused) {
            const dOpt = document.createElement("option");
            dOpt.value = label;
            datalist.appendChild(dOpt);
          }
        }
      });
      if (!select.value && select.options.length) select.selectedIndex = 0;
      select.onchange = () => playSong(true);
    }

    function filterSelected() {
      const filterVal = document.getElementById("songFilter").value.toLowerCase();
      const select = document.getElementById("songSelect");
      for (let i = 0; i < select.options.length; i++) {
        if (select.options[i].textContent.toLowerCase() === filterVal) {
          select.selectedIndex = i;
          playSong(true);
          break;
        }
      }
    }

    function refreshSongs() {
      api("/songs").then(r => r.json()).then(s => {
        if (!state.songs) state.songs = {};
        state.songs.library = s.library || {};
        state.songs.background = s.background || state.songs.background;
        state.songs.current = state.songs.current || s.current || "";
        renderSongs();
        ensureBackground();
      });
    }

    async function playSong(fromSelect=false) {
      const select = document.getElementById("songSelect");
      const url = select.value;
      if (!url) {
        if (fromSelect) return;
        return alert("Enter a song URL");
      }
      // cancel routine if user manually picks music
      cancelRoutine();
      await api("/songs/play", {method:"POST", body:{target: currentTab, url}});
      const songs = state.songs || {};
      songs.current = url;
      songs[currentTab] = url;
      state.songs = songs;
      // play selected -> applause -> background
      startAudio(url, {loop:false, onEnd: () => {
        playSequence(["applause"], false, () => {
          const bg = state.songs?.background;
          if (bg) startAudio(bg, {loop:true});
        });
      }});
      refreshState();
    }

    function startAudio(url, opts={}) {
      const player = document.getElementById("player");
      const fadeIn = opts.fade ?? document.getElementById("fadeToggle")?.checked ?? true;
      const fadeOut = opts.fadeOut ?? document.getElementById("fadeOutToggle")?.checked ?? true;
      const doPlay = () => {
        player.loop = !!opts.loop;
        player.onended = () => {
          if (typeof opts.onEnd === "function") {
            opts.onEnd();
            return;
          }
          const bg = state.songs?.background;
          if (bg) {
            startAudio(bg, {loop:true});
          }
        };
        player.src = url;
        if (!opts.isRole) {
          notePlay(url);
        }
        if (fadeIn) {
          let vol = 0.0;
          player.volume = 0;
          player.play();
          const steps = 10;
          const stepMs = 50;
          const inc = 1/steps;
          let count = 0;
          const intv = setInterval(()=>{
            count += 1;
            vol = Math.min(1, vol + inc);
            player.volume = vol;
            if (count >= steps) clearInterval(intv);
          }, stepMs);
        } else {
          player.volume = 1;
          player.play();
        }
      };
      // only fade out on normal transitions; skip fading when interrupting (opts.skipFadeOut)
      if (fadeOut && !opts.skipFadeOut && !player.paused && player.src) {
        let vol = player.volume;
        const steps = 10;
        const stepMs = 50;
        const dec = vol/steps;
        let count = 0;
        const outv = setInterval(()=>{
          count += 1;
          vol = Math.max(0, vol - dec);
          player.volume = vol;
          if (count >= steps) {
            clearInterval(outv);
            player.pause();
            doPlay();
          }
        }, stepMs);
      } else {
        doPlay();
      }
    }

    function getRoleUrl(role) {
      const lib = state.songs?.library || {};
      for (const key of Object.keys(lib)) {
        const roles = lib[key].roles || [];
        if (roles.includes(role)) return lib[key].url;
      }
      return null;
    }

    function ensureBackground() {
      const lib = state.songs?.library || {};
      const bgExplicit = state.songs?.background;
      let bg = bgExplicit;
      if (!bg) {
        bg = getRoleUrl("background");
        if (bg) {
          api("/songs/play", {method:"POST", body:{target:"background", url:bg}});
          state.songs = state.songs || {};
          state.songs.background = bg;
          state.songs.current = state.songs.current || bg;
        }
      }
      if (bg) {
        startAudio(bg, {loop:true});
      }
    }

    function pickRandom(arr) {
      if (!arr?.length) return null;
      const processed = arr.map(item => {
        const key = typeof item === "string" ? item : (item?.url || item?.id || null);
        const count = key ? (playCounts[key] || 0) : 0;
        return { item, key, count };
      });
      let candidates = processed;
      if (processed.length > 1 && lastSongUrl) {
        const filtered = processed.filter(p => p.key && p.key !== lastSongUrl);
        if (filtered.length) candidates = filtered;
      }
      const weights = candidates.map(p => p.key ? 1 / (1 + p.count) : 1);
      const total = weights.reduce((a,b)=>a+b,0);
      let r = Math.random() * total;
      for (let i=0;i<candidates.length;i++) {
        r -= weights[i];
        if (r <= 0) return candidates[i].item;
      }
      return candidates[candidates.length-1].item;
    }

    function tickPoints() {
      if (!routine.active || !routine.startTime || !routine.endTime) return;
      const now = Date.now();
      const remaining = routine.endTime - now;
      if (remaining <= 0) {
        stopPointsInterval();
        return;
      }
      const scores = state.scores || {slot_one:0, slot_two:0};
      const a = scores.slot_one || 0;
      const b = scores.slot_two || 0;
      const totalPts = Math.max(1, a + b);
      const mean = Math.max(1, Math.round(totalPts * 0.05)); // 5% of current total points
      let amount = Math.max(1, Math.round(Math.random() * mean) + 1);
      let slot = Math.random() < 0.5 ? "slot_one" : "slot_two";
      const diff = (scores.slot_one||0) - (scores.slot_two||0);
      const losing = diff > 0 ? "slot_two" : diff < 0 ? "slot_one" : null;
      if (losing && Math.random() < 0.03) { // comeback chance
        slot = losing;
        amount += Math.round(mean * 25);
      }
      api(`/score/${slot}/add`, {method:"POST", body:{amount}}).then(refreshState);
    }

    function getEnabledDancers() {
      const enabled = state.enabled_dancers || [];
      const set = new Set((enabled || []).map(x => (x || "").toLowerCase()));
      const pool = state.dancers || [];
      if (!enabled.length) return pool;
      return pool.filter(d => set.has((d.name || "").toLowerCase()));
    }

    function chooseTwoDancers() {
      const dancers = getEnabledDancers();
      if (dancers.length < 2) return ["Dancer A", "Dancer B"];
      if (nextPairOverride && nextPairOverride.length === 2) {
        const pair = nextPairOverride;
        nextPairOverride = null;
        setNextPairLabel("-");
        return pair;
      }
      const last = (state.last_winner || "").toLowerCase();
      const match = dancers.find(d => (d.name||"").toLowerCase() === last);
      const others = dancers.filter(d => d !== match);
      const pickOther = others.length ? others[Math.floor(Math.random()*others.length)] : null;
      if (match && pickOther) {
        return [match.name || "Dancer A", pickOther.name || "Dancer B"];
      }
      const shuffled = [...dancers].sort(()=>Math.random()-0.5);
      return [shuffled[0].name || "Dancer A", shuffled[1].name || "Dancer B"];
    }

    function setNextPairLabel(text) {
      const el = document.getElementById("nextPairLabel");
      if (el) el.textContent = `Next pair: ${text || "-"}`;
    }

    function pickNextPair() {
      const dancers = getEnabledDancers();
      if (dancers.length < 2) {
        alert("Need at least two enabled dancers");
        return;
      }
      const sel = document.getElementById("nextPairSelect");
      const desired = (sel?.value || "").trim();
      const last = (state.last_winner || "").toLowerCase();
      const winner = dancers.find(d => (d.name || "").toLowerCase() === last);
      const others = winner ? dancers.filter(d => d !== winner) : dancers;
      let pair;
      if (desired) {
        const target = dancers.find(d => (d.name || "").toLowerCase() === desired.toLowerCase());
        if (target) {
          if (winner && winner !== target) {
            pair = [winner.name || "Dancer A", target.name || "Dancer B"];
          } else {
            const pool = dancers.filter(d => d !== target);
            const partner = pool.length ? pool[Math.floor(Math.random()*pool.length)] : null;
            if (partner) pair = [target.name || "Dancer A", partner.name || "Dancer B"];
          }
        }
      }
      if (!pair) {
        if (winner && others.length) {
          const challenger = others[Math.floor(Math.random() * others.length)];
          pair = [winner.name || "Dancer A", challenger.name || "Dancer B"];
        } else {
          const shuffled = [...dancers].sort(() => Math.random() - 0.5);
          pair = [shuffled[0].name || "Dancer A", shuffled[1].name || "Dancer B"];
        }
      }
      nextPairOverride = pair;
      setNextPairLabel(pair.join(" vs "));
    }

    function songsForDancer(name) {
      const lib = state.songs?.library || {};
      const target = (name||"").toLowerCase();
      return Object.values(lib).filter(s => {
        const dancers = (s.dancers||[]).map(x=>x.toLowerCase());
        return dancers.includes(target);
      });
    }

    function songsKnownBy(name) {
      const lib = state.songs?.library || {};
      const target = (name||"").toLowerCase();
      return Object.values(lib).filter(s => {
        const knows = (s.knows_song||[]).map(x=>x.toLowerCase());
        return knows.includes(target);
      });
    }

    function intersectSongsFor(a, b) {
      const lib = state.songs?.library || {};
      const mapUrl = {};
      Object.values(lib).forEach(s => { if (s.url) mapUrl[s.url] = s; });

      const assignedA = new Set(songsForDancer(a).map(s => s.url));
      const knowsA = new Set(songsKnownBy(a).map(s => s.url));
      const assignedB = new Set(songsForDancer(b).map(s => s.url));
      const knowsB = new Set(songsKnownBy(b).map(s => s.url));

      // Must be assigned to at least one dancer AND known by both
      const assignedAny = new Set([...assignedA, ...assignedB]);
      const unionA = new Set([...assignedA, ...knowsA]);
      const unionB = new Set([...assignedB, ...knowsB]);
      const shared = new Set([...unionA].filter(u => unionB.has(u) && assignedAny.has(u)));

      const urls = new Set(shared);
      const result = [];
      urls.forEach(u => { if (mapUrl[u]) result.push(mapUrl[u]); });
      return result;
    }

    function markRoutinePlayed(url) {
      if (!url) return;
      if (!routine.playedSongs) routine.playedSongs = new Set();
      routine.playedSongs.add(url);
    }

    function scoresForDancers(a, b) {
      const scores = state.scores || {slot_one:0, slot_two:0};
      const slotOneName = (state.slot_one || "").toLowerCase();
      const slotTwoName = (state.slot_two || "").toLowerCase();
      const aName = (a||"").toLowerCase();
      const bName = (b||"").toLowerCase();
      const scoreA = aName === slotOneName ? scores.slot_one || 0 : aName === slotTwoName ? scores.slot_two || 0 : 0;
      const scoreB = bName === slotOneName ? scores.slot_one || 0 : bName === slotTwoName ? scores.slot_two || 0 : 0;
      if (scoreA === scoreB) return null;
      return scoreA > scoreB
        ? {leader:a, loser:b, leaderScore:scoreA, loserScore:scoreB}
        : {leader:b, loser:a, leaderScore:scoreB, loserScore:scoreA};
    }

    function isGroupSong(url) {
      return groupSongs().some(s => s.url === url);
    }

    function decideNextSong(currentUrl) {
      const dancers = routine.dancers || [];
      if (dancers.length < 2) return getRoleUrl("background");
      const played = routine.playedSongs || new Set();
      const scoreInfo = scoresForDancers(dancers[0], dancers[1]);
      // First song logic prefers shared/group
      if (!routine.firstSongPlayed) {
        const both = intersectSongsFor(dancers[0], dancers[1]).filter(s => !(s.roles||[]).some(r=>SPECIAL_ROLES.includes(r))).filter(s => !played.has(s.url));
        if (both.length) return pickRandom(both).url;
        const groups = groupSongs().filter(s => !(s.roles||[]).some(r=>SPECIAL_ROLES.includes(r))).filter(s => !played.has(s.url));
        if (groups.length) return pickRandom(groups).url;
        // if exhausted, allow repeats of shared/group
        const bothRepeat = intersectSongsFor(dancers[0], dancers[1]).filter(s => !(s.roles||[]).some(r=>SPECIAL_ROLES.includes(r)));
        if (bothRepeat.length) return pickRandom(bothRepeat).url;
        const groupRepeat = groupSongs().filter(s => !(s.roles||[]).some(r=>SPECIAL_ROLES.includes(r)));
        if (groupRepeat.length) return pickRandom(groupRepeat).url;
      }
      if (!scoreInfo) return currentUrl || getRoleUrl("background");
      const {leader, loser, leaderScore, loserScore} = scoreInfo;
      return pickSongByMargin(leader, loser, leaderScore, loserScore, currentUrl, played);
    }

    function pickSongByMargin(leader, loser, leaderScore, loserScore, currentUrl=null, played=new Set()) {
      const leaderAssigned = songsForDancer(leader).filter(s => !(s.roles||[]).some(r=>SPECIAL_ROLES.includes(r)));
      const loserAssigned = new Set(songsForDancer(loser).map(s => s.url));
      const loserKnows = new Set(songsKnownBy(loser).map(s => s.url));
      const isHighMargin = leaderScore > loserScore * 1.2;
      const exclude = (list) => list.filter(s => s.url !== currentUrl && !played.has(s.url));

      if (isHighMargin) {
        const pool = exclude(leaderAssigned);
        const pick = pickRandom(pool.length ? pool : leaderAssigned);
        return pick ? pick.url : null;
      }
      const shared = exclude(leaderAssigned).filter(s => loserAssigned.has(s.url) || loserKnows.has(s.url));
      if (shared.length) {
        const pick = pickRandom(shared);
        return pick ? pick.url : null;
      }
      const groups = groupSongs().filter(s => !(s.roles||[]).some(r=>SPECIAL_ROLES.includes(r))).filter(s => !played.has(s.url) && s.url !== currentUrl);
      const pickGroup = pickRandom(groups.length ? groups : groupSongs());
      return pickGroup ? pickGroup.url : null;
    }

    function groupSongs() {
      const group = (state.group_name || "").toLowerCase();
      const lib = state.songs?.library || {};
      return Object.values(lib).filter(s => {
        const dancers = (s.dancers||[]).map(x=>x.toLowerCase());
        return group && dancers.includes(group);
      });
    }

    function pickSongFor(name, excludeUrl=null) {
      const pool = songsForDancer(name).filter(s => !(s.roles||[]).some(r=>SPECIAL_ROLES.includes(r)));
      const filtered = excludeUrl ? pool.filter(s => s.url !== excludeUrl) : pool;
      const chosen = pickRandom(filtered.length ? filtered : pool);
      return chosen ? chosen.url : null;
    }

    function getLeaderName() {
      const scores = state.scores || {slot_one:0, slot_two:0};
      const a = scores.slot_one || 0;
      const b = scores.slot_two || 0;
      if (a > b) return state.slot_one || "";
      if (b > a) return state.slot_two || "";
      return "";
    }

    function nextSongFor(dancerA, dancerB, excludeUrl=null) {
      const pool = [...songsForDancer(dancerA), ...songsForDancer(dancerB)].filter(s => !(s.roles||[]).some(r=>SPECIAL_ROLES.includes(r)));
      const filtered = pool.filter(s => s.url !== excludeUrl);
      const chosen = pickRandom(filtered.length ? filtered : pool);
      return chosen ? chosen.url : null;
    }

    function clearRoutineTimers() {
      routine.timers.forEach(t=>clearTimeout(t));
      routine.timers = [];
    }

    function stopTimerInterval() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    function startPointsInterval() {
      stopPointsInterval();
      routine.pointsInterval = setInterval(tickPoints, 1000);
    }

    function stopPointsInterval() {
      if (routine.pointsInterval) {
        clearInterval(routine.pointsInterval);
        routine.pointsInterval = null;
      }
    }

    function stopSwitchInterval() {
      if (routine.switchInterval) {
        clearInterval(routine.switchInterval);
        routine.switchInterval = null;
      }
    }

    function startRoutine() {
      clearRoutineTimers();
      routine.active = true;
      routine.startTime = Date.now();
      routine.endTime = routine.startTime + 120000; // 2 minutes
      routine.dancers = chooseTwoDancers();
      routine.firstSongPlayed = false;
      routine.warned = false;
       routine.playedSongs = new Set();
      startPointsInterval();
      setCenterLine(true);
      api("/battle/start", {method:"POST", body:{}}).then(()=> {
        api("/battle/slot/slot_one", {method:"POST", body:{slot_one: routine.dancers[0], slot_two: routine.dancers[1]}}).catch(()=>{});
        api("/battle/slot/slot_two", {method:"POST", body:{slot_one: routine.dancers[0], slot_two: routine.dancers[1]}}).catch(()=>{});
        saveWinnerValue(routine.dancers[0]); // pre-fill last winner with first dancer for convenience
      });
      playRoutineSong(null);
      renderTimer(true);
      renderWinnerSelect();
    }

   function skipSong() {
      const next = decideNextSong(routine.currentSongUrl);
      if (!next || next === routine.currentSongUrl) return;
      markRoutinePlayed(next);
      routine.currentSongUrl = next;
      api("/songs/play", {method:"POST", body:{target:"group", url: next}}).catch(()=>{});
      playSequence(["bell"], false, () => {
        startAudio(next, {skipFadeOut:true, loop:false, onEnd: () => {
          const after = decideNextSong(next);
          if (!after) return;
          playSequence(["bell"], false, () => playRoutineSong(after));
        }});
      });
    }

    function cancelRoutine() {
      routine.active = false;
      routine.warned = false;
      routine.playedSongs = new Set();
      clearRoutineTimers();
      stopPointsInterval();
      stopSwitchInterval();
      const player = document.getElementById("player");
      try { player.pause(); } catch(e){}
      ensureBackground();
      stopTimerInterval();
      setCenterLine(false);
      renderTimer(true);
    }

    function playRoutineSong(lastUrl) {
      if (!routine.active) return;
      const now = Date.now();
      const remaining = routine.endTime - now;
      if (remaining <= 0) {
        playSequence(["applause","win"], true);
        routine.active = false;
        stopPointsInterval();
        stopSwitchInterval();
        evaluateWinner();
        return;
      }
      if (remaining <= 30000) {
        // stop current audio
        const player = document.getElementById("player");
        try { player.pause(); } catch(e){}
        setCenterLine(false);
        stopSwitchInterval();
        playSequence(["applause","attention"], false, () => {
          const wait = Math.max(0, routine.endTime - Date.now());
          const t = setTimeout(() => playRoutineSong(null), wait);
          routine.timers.push(t);
        });
        return;
      }
      const url = decideNextSong(lastUrl) || getRoleUrl("background");
      if (!url) { ensureBackground(); return; }
      const afterDoorbell = () => {
        api("/songs/play", {method:"POST", body:{target:"group", url}}).catch(()=>{});
        if (!state.songs) state.songs = {};
        state.songs.current = url;
        routine.currentSongOwner = routine.firstSongPlayed ? getLeaderName() : "";
        routine.currentSongUrl = url;
        markRoutinePlayed(url);
        stopSwitchInterval();
        routine.switchInterval = setInterval(() => monitorSongSwitch(), 2000);
        startAudio(url, {loop:false, onEnd: () => {
          const next = decideNextSong(url);
          if (!next) return;
          playSequence(["bell"], false, () => playRoutineSong(next));
        }});
      };
      if (!routine.firstSongPlayed) {
        routine.firstSongPlayed = true;
        playSequence(["bell"], false, afterDoorbell);
      } else {
        afterDoorbell();
      }
    }

    function playSequence(roleNames, loopLast=false, onDone=null) {
      const [first, ...rest] = roleNames;
      const url = getRoleUrl(first);
      if (!url) { if (rest.length) return playSequence(rest, loopLast, onDone); if (onDone) onDone(); return; }
      startAudio(url, {loop: loopLast && rest.length===0, isRole:true, onEnd: () => {
        if (!rest.length) { if (onDone) onDone(); return; }
        playSequence(rest, loopLast, onDone);
      }});
    }

    function setCenterLine(show) {
      api(`/overlay/${CENTER_LINE}/${show ? "show" : "hide"}`, {method:"POST"}).catch(()=>{});
      if (state.overlay_states) state.overlay_states[CENTER_LINE] = show;
    }

    function playRole(role) {
      const url = getRoleUrl(role);
      if (!url) {
        alert(`No song with role: ${role}`);
        return;
      }
      api("/songs/play", {method:"POST", body:{target:"group", url}}).catch(()=>{});
      startAudio(url, {loop:false});
    }

    function saveWinnerValue(name) {
      api("/battle/winner", {method:"POST", body:{name}});
      const sel = document.getElementById("winnerSelect");
      if (sel) sel.value = name;
    }

    function saveWinnerSelect() {
      const sel = document.getElementById("winnerSelect");
      if (!sel) return;
      saveWinnerValue(sel.value);
    }

    function saveGroupValue(name) {
      api("/battle/group", {method:"POST", body:{name}});
      const sel = document.getElementById("groupSelect");
      if (sel) sel.value = name;
    }

    function saveGroupSelect() {
      const sel = document.getElementById("groupSelect");
      if (!sel) return;
      saveGroupValue(sel.value);
      renderSongs();
    }

    function toggleEnabledDancer(name, enabled) {
      const list = new Set(state.enabled_dancers || []);
      if (enabled) list.add(name); else list.delete(name);
      const arr = Array.from(list);
      api("/dancers/enabled", {method:"POST", body:{names: arr}});
      state.enabled_dancers = arr;
      renderWinnerSelect();
      renderGroupSelect();
      renderSongs();
    }

    function evaluateWinner() {
      const scores = state.scores || {slot_one:0, slot_two:0};
      const a = scores.slot_one || 0;
      const b = scores.slot_two || 0;
      if (a === b) return;
      const winnerName = a > b ? (state.slot_one || "") : (state.slot_two || "");
      const target = winnerName || (a > b ? "slot_one" : "slot_two");
      api("/battle/win", {method:"POST", body:{name: target}});
      if (winnerName) saveWinnerValue(winnerName);
      refreshState();
    }

    function monitorSongSwitch() {
      if (!routine.active || !routine.currentSongUrl) return;
      if (!routine.dancers || routine.dancers.length < 2) return;
      const [a, b] = routine.dancers;
      const shared = intersectSongsFor(a, b).some(s => s.url === routine.currentSongUrl);
      const isGroup = isGroupSong(routine.currentSongUrl);
      const scoreInfo = scoresForDancers(a, b);
      if (!scoreInfo) return;
      const {leader, loser, leaderScore, loserScore} = scoreInfo;
      const loserAssigned = songsForDancer(loser).some(s => s.url === routine.currentSongUrl);
      if (shared || isGroup) return;
      // If the current song owner is the leader and leader is ahead, let it keep playing
      if ((routine.currentSongOwner || "").toLowerCase() === (leader || "").toLowerCase()) return;
      // Otherwise (loser overtook or no owner), switch by margin logic
      const newUrl = pickSongByMargin(leader, loser, leaderScore, loserScore, routine.currentSongUrl);
      if (!newUrl || newUrl === routine.currentSongUrl) return;
      routine.currentSongOwner = leader;
      routine.currentSongUrl = newUrl;
      markRoutinePlayed(newUrl);
      api("/songs/play", {method:"POST", body:{target:"group", url:newUrl}}).catch(()=>{});
      playSequence(["bell"], false, () => {
        startAudio(newUrl, {skipFadeOut:true, loop:false, onEnd: () => {
          const next = decideNextSong(newUrl);
          if (!next) return;
          playSequence(["bell"], false, () => playRoutineSong(next));
        }});
      });
    }

    function renderTimer(force=false) {
      const el = document.getElementById("timerDisplay");
      if (!el) return;
      const update = () => {
        if (!routine.active || !routine.endTime) {
          el.textContent = "-";
          el.style.color = "#e2e8f0";
          stopTimerInterval();
          return;
        }
        const remaining = Math.max(0, Math.ceil((routine.endTime - Date.now()) / 1000));
        const mins = String(Math.floor(remaining / 60)).padStart(2,"0");
        const secs = String(remaining % 60).padStart(2,"0");
        el.textContent = `${mins}:${secs}`;
       el.style.color = remaining <= 30 ? "#ef4444" : "#e2e8f0";
       if (remaining <= 30 && remaining > 0 && !routine.warned) {
         // once under 30s, stop current and force applause->attention
         const player = document.getElementById("player");
         try { player.pause(); } catch(e){}
         playSequence(["applause","attention"], false);
         routine.warned = true;
         setCenterLine(false);
         stopSwitchInterval();
       }
       if (remaining <= 0) {
         routine.active = false;
         routine.warned = false;
         stopTimerInterval();
          stopPointsInterval();
          const player = document.getElementById("player");
          try { player.pause(); } catch(e){}
          evaluateWinner();
          playSequence(["applause","win"], true);
        }
      };
      if (!timerInterval || force) {
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(update, 1000);
      }
      update();
    }


    async function refreshCameras() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        // Only list physical/non-virtual cams for feeding into the virtual cam
        const cams = devices.filter(d => d.kind === "videoinput" && !/virtual/i.test(d.label || ""));
        const select = document.getElementById("cameraSelect");
        select.innerHTML = "";
        cams.forEach((cam, idx) => {
          const opt = document.createElement("option");
          opt.value = cam.deviceId || "";
          opt.dataset.idx = idx;
          opt.dataset.label = cam.label || `Camera ${idx}`;
          opt.textContent = cam.label || `Camera ${idx}`;
          select.appendChild(opt);
        });
        if (!select.value && cams[0]) select.value = cams[0].deviceId;
      } catch (e) {
        console.warn("Camera enumeration failed", e);
      }
    }

    async function startPreview() {
      const video = document.getElementById("preview");
      if (!navigator.mediaDevices?.getUserMedia) return alert("getUserMedia not supported");
      try {
        await applyCamera();
        // Always preview the virtual camera; fall back to first device
        const refreshed = await navigator.mediaDevices.enumerateDevices();
        const vcams = refreshed.filter(d => d.kind === "videoinput");
        const virtualTarget = vcams.find(c => /virtual/i.test(c.label || "")) || vcams[0];
        if (!virtualTarget) return alert("No camera found");
        const constraints = virtualTarget.deviceId ? { deviceId: { exact: virtualTarget.deviceId } } : true;
        const stream = await navigator.mediaDevices.getUserMedia({ video: constraints });
        video.srcObject = stream;
        await video.play();
      } catch (err) {
        alert("Camera access denied or unavailable: " + err);
      }
    }

    function applyCamera() {
      const select = document.getElementById("cameraSelect");
      const idx = Number(select.selectedOptions[0]?.dataset.idx ?? 0);
      const label = select.selectedOptions[0]?.dataset.label || "";
      return api("/camera/select", {method:"POST", body:{index: idx, label}}).then(()=>refreshState());
    }

    // Initial camera list load
    refreshCameras();
    highlightNav();

    // WebSocket live updates
    function connectWs() {
      const ws = new WebSocket((location.origin.replace(/^http/,"ws")) + "/ws/state");
      ws.onopen = () => { const d=document.getElementById("wsDot"); const t=document.getElementById("statusText"); if(d){d.style.background="#22c55e"; d.style.boxShadow="0 0 8px #22c55e";} if(t) t.textContent="Live"; };
      const markDown = () => {
        const d=document.getElementById("wsDot"); const t=document.getElementById("statusText");
        if(d){d.style.background="#ef4444"; d.style.boxShadow="0 0 8px #ef4444";}
        if(t) t.textContent="Disconnected";
        setTimeout(connectWs, 2000);
      };
      ws.onerror = markDown;
      ws.onclose = markDown;
      ws.onmessage = evt => { try { const data = JSON.parse(evt.data); if(data.type==="state"){ state = data.payload; renderState(); }} catch(e){} };
    }
    connectWs();

    refreshState();
    refreshSongs();
  </script>
</body>
</html>
